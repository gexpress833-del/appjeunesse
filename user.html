<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Utilisateur</title>
  <link rel="stylesheet" href="css/styles.css" />
</head>
<body data-page-role="user">
  <div class="app">
    <div class="panel">
      <header>
        <div class="header-left">
          <img src="images/logo.jpg" alt="Logo" class="app-logo">
          <div class="app-title">
            <span class="app-name">La Parole Eternelle</span>
            <span class="app-subtitle">Utilisateur</span>
          </div>
        </div>
        <div class="header-center">
          <div class="profile-avatar" id="headerProfilePhoto">
            <span id="headerInitials">U</span>
          </div>
          <div class="header-info">
            <h1 class="header-title">Tableau de bord</h1>
            <span class="welcome-message">Bienvenue, Utilisateur</span>
          </div>
        </div>
        <div class="login-panel">
          <div class="notification-bell" onclick="openNotificationCenter()">
            üîî
            <span class="notification-badge" id="notificationBadge">0</span>
          </div>
          <div class="user-info">
            <span class="user-role">R√¥le : <strong>Utilisateur</strong></span>
            <span class="user-status">‚óè En ligne</span>
          </div>
          <button class="secondary logout-btn" id="logoutBtn" type="button">D√©connexion</button>
        </div>
      </header>
      <nav class="nav role-nav">
        <a href="index.html">Accueil</a>
        <a href="members.html" data-section="members">Consulter la liste</a>
        <a href="events.html" data-section="events">√âv√©nements</a>
        <a href="attendances.html" data-section="attendances">Pr√©sences</a>
        <a href="profile.html">üë§ Mon Profil</a>
      </nav>
      <section class="grid role-stats">
        <div class="card">
          <h3>Membres visibles</h3>
          <p class="value" id="roleStatMembers">0</p>
        </div>
        <div class="card">
          <h3>Pr√©sences</h3>
          <p class="value" id="roleStatAttendance">0 %</p>
        </div>
      </section>
      <section class="card" style="margin-top:1.5rem;">
        <h3>Consultation</h3>
        <div class="form-actions" style="margin-top:1rem;">
          <a class="primary" href="members.html">Voir les membres</a>
          <a class="primary" href="events.html">Voir les √©v√©nements</a>
          <a class="primary" href="attendances.html">Voir les pr√©sences</a>
        </div>
      </section>
      
      <!-- Section √âv√©nements en cours -->
      <section class="card" style="margin-top:1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="margin: 0;">üü¢ √âv√©nements en cours</h3>
          <span id="currentEventsBadge" style="background: #10b981; color: white; padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.85rem; font-weight: 600;">0</span>
        </div>
        <div id="currentEvents" style="margin-top:1rem;">
          <p style="color: #94a3b8; text-align: center;">Chargement des √©v√©nements...</p>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="secondary" onclick="refreshCurrentEvents()" style="font-size: 0.85rem; padding: 0.5rem 1rem;">
            üîÑ Actualiser
          </button>
        </div>
      </section>
      
      <!-- Section √âv√©nements √† venir -->
      <section class="card" style="margin-top:1.5rem;">
        <h3>üìÖ √âv√©nements √† venir</h3>
        <div id="upcomingEvents" style="margin-top:1rem;">
          <p style="color: #94a3b8; text-align: center;">Chargement des √©v√©nements...</p>
        </div>
      </section>
      
      <!-- Section Graphique d'√©volution du taux de pr√©sence -->
      <section class="card" style="margin-top:1.5rem;">
        <h3>üìà √âvolution de mon taux de pr√©sence</h3>
        <div id="attendanceChartContainer" style="margin-top:1rem; min-height: 250px; position: relative;">
          <canvas id="attendanceChart" style="width: 100%; height: 250px;"></canvas>
          <div id="chartLoading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #94a3b8;">
            Chargement des donn√©es...
          </div>
          <div id="chartNoData" style="display: none; text-align: center; padding: 2rem; color: #94a3b8;">
            <p>Aucune donn√©e de pr√©sence disponible pour afficher l'√©volution.</p>
            <p style="font-size: 0.85rem; margin-top: 0.5rem;">Vos statistiques appara√Ætront ici apr√®s votre premi√®re pr√©sence enregistr√©e.</p>
          </div>
        </div>
        <div style="margin-top: 1rem; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: #94a3b8;">
          <span id="chartStats">Taux moyen: <strong id="averageRate">-</strong></span>
          <span>Total √©v√©nements: <strong id="totalEventsCount">0</strong></span>
        </div>
      </section>
      
      <!-- Section Historique des √©v√©nements pass√©s -->
      <section class="card" style="margin-top:1.5rem;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="margin: 0;">üìö Historique des √©v√©nements</h3>
          <button class="secondary" onclick="toggleEventHistory()" style="font-size: 0.85rem; padding: 0.5rem 1rem;" id="toggleHistoryBtn">
            Afficher
          </button>
        </div>
        <div id="pastEvents" style="margin-top:1rem; display: none; max-height: 500px; overflow-y: auto;">
          <p style="color: #94a3b8; text-align: center;">Chargement de l'historique...</p>
        </div>
      </section>
    </div>
  </div>
  <!-- Supabase Client Library -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  
  <!-- Configuration Supabase -->
  <script src="js/config.js"></script>
  
  <!-- Module Supabase -->
  <script src="js/supabase.js"></script>
  
  <script src="js/data.js" defer></script>
  <script src="js/auth.js" defer></script>
  <script src="js/notifications.js" defer></script>
  <script src="js/role-page.js" defer></script>
  <script src="js/events.js" defer></script>
  
  <script>
    // Fonction utilitaire pour obtenir le statut d'un √©v√©nement
    function getEventStatus(eventDate) {
      const today = new Date();
      const event = new Date(eventDate);
      today.setHours(0, 0, 0, 0);
      event.setHours(0, 0, 0, 0);
      
      if (event.getTime() === today.getTime()) {
        return 'current';
      } else if (event > today) {
        return 'upcoming';
      } else {
        return 'past';
      }
    }
    
    // Charger tous les √©v√©nements depuis Supabase
    async function loadAllEvents() {
      try {
        if (!window.supabaseDB || !window.supabaseDB.getClient()) {
          throw new Error('Supabase n\'est pas configur√©');
        }
        
        const events = await window.supabaseDB.getEvents();
        return events.map(evt => ({
          id: evt.id,
          name: evt.name,
          date: evt.date,
          description: evt.description,
          photoUrl: evt.photo_url
        }));
      } catch (error) {
        console.error('Erreur lors du chargement des √©v√©nements:', error);
        return [];
      }
    }
    
    // Afficher les √©v√©nements en cours
    async function loadCurrentEvents() {
      const currentEventsDiv = document.getElementById('currentEvents');
      const badge = document.getElementById('currentEventsBadge');
      if (!currentEventsDiv) return;
      
      try {
        const events = await loadAllEvents();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const current = events.filter(evt => {
          const eventDate = new Date(evt.date);
          eventDate.setHours(0, 0, 0, 0);
          return eventDate.getTime() === today.getTime();
        }).sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (badge) {
          badge.textContent = current.length;
          badge.style.display = current.length > 0 ? 'inline-block' : 'none';
        }
        
        if (current.length === 0) {
          currentEventsDiv.innerHTML = '<p style="color: #94a3b8; text-align: center;">Aucun √©v√©nement en cours aujourd\'hui</p>';
          return;
        }
        
        currentEventsDiv.innerHTML = current.map(evt => {
          const eventDate = new Date(evt.date);
          const formattedDate = eventDate.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Calculer le temps restant (si c'est aujourd'hui)
          const now = new Date();
          const hours = now.getHours();
          const minutes = now.getMinutes();
          const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
          
          return `
            <div style="padding: 1rem; margin-bottom: 0.5rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); border-radius: 0.5rem; border-left: 4px solid #10b981; position: relative;">
              <div style="position: absolute; top: 0.5rem; right: 0.5rem; background: #10b981; color: white; padding: 0.25rem 0.75rem; border-radius: 1rem; font-size: 0.75rem; font-weight: 600;">
                EN COURS
              </div>
              <h4 style="margin: 0 0 0.5rem 0; color: #10b981; font-size: 1.1rem;">${evt.name}</h4>
              <p style="margin: 0; color: #94a3b8; font-size: 0.9rem;">üìÖ ${formattedDate}</p>
              <p style="margin: 0.25rem 0 0 0; color: #6ee7b7; font-size: 0.85rem; font-weight: 600;">üïê ${timeString}</p>
              ${evt.description ? `<p style="margin: 0.5rem 0 0 0; color: #cbd5e1; font-size: 0.85rem;">${evt.description.substring(0, 150)}${evt.description.length > 150 ? '...' : ''}</p>` : ''}
              <div style="margin-top: 0.75rem;">
                <a href="events.html" class="primary" style="display: inline-block; padding: 0.5rem 1rem; font-size: 0.85rem; text-decoration: none;">Voir les d√©tails ‚Üí</a>
              </div>
            </div>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Erreur lors du chargement des √©v√©nements en cours:', error);
        currentEventsDiv.innerHTML = '<p style="color: #ef4444; text-align: center;">Erreur lors du chargement des √©v√©nements</p>';
      }
    }
    
    // Afficher les √©v√©nements √† venir
    async function loadUpcomingEvents() {
      const upcomingEventsDiv = document.getElementById('upcomingEvents');
      if (!upcomingEventsDiv) return;
      
      try {
        const events = await loadAllEvents();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const upcoming = events.filter(evt => {
          const eventDate = new Date(evt.date);
          eventDate.setHours(0, 0, 0, 0);
          return eventDate > today;
        }).sort((a, b) => new Date(a.date) - new Date(b.date)).slice(0, 5);
        
        if (upcoming.length === 0) {
          upcomingEventsDiv.innerHTML = '<p style="color: #94a3b8; text-align: center;">Aucun √©v√©nement √† venir</p>';
          return;
        }
        
        upcomingEventsDiv.innerHTML = upcoming.map(evt => {
          const eventDate = new Date(evt.date);
          const formattedDate = eventDate.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Calculer les jours restants
          const daysUntil = Math.ceil((eventDate - today) / (1000 * 60 * 60 * 24));
          const daysText = daysUntil === 1 ? 'demain' : `dans ${daysUntil} jours`;
          
          return `
            <div style="padding: 1rem; margin-bottom: 0.5rem; background: rgba(59, 130, 246, 0.1); border-radius: 0.5rem; border-left: 3px solid #3b82f6;">
              <h4 style="margin: 0 0 0.5rem 0; color: #60a5fa;">${evt.name}</h4>
              <p style="margin: 0; color: #94a3b8; font-size: 0.9rem;">üìÖ ${formattedDate}</p>
              <p style="margin: 0.25rem 0 0 0; color: #93c5fd; font-size: 0.85rem; font-weight: 600;">‚è∞ ${daysText}</p>
              ${evt.description ? `<p style="margin: 0.5rem 0 0 0; color: #cbd5e1; font-size: 0.85rem;">${evt.description.substring(0, 100)}${evt.description.length > 100 ? '...' : ''}</p>` : ''}
            </div>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Erreur lors du chargement des √©v√©nements:', error);
        upcomingEventsDiv.innerHTML = '<p style="color: #ef4444; text-align: center;">Erreur lors du chargement des √©v√©nements</p>';
      }
    }
    
    // Afficher l'historique des √©v√©nements pass√©s
    async function loadPastEvents() {
      const pastEventsDiv = document.getElementById('pastEvents');
      if (!pastEventsDiv) return;
      
      try {
        const events = await loadAllEvents();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        const past = events.filter(evt => {
          const eventDate = new Date(evt.date);
          eventDate.setHours(0, 0, 0, 0);
          return eventDate < today;
        }).sort((a, b) => new Date(b.date) - new Date(a.date)); // Plus r√©cents en premier
        
        if (past.length === 0) {
          pastEventsDiv.innerHTML = '<p style="color: #94a3b8; text-align: center;">Aucun √©v√©nement dans l\'historique</p>';
          return;
        }
        
        pastEventsDiv.innerHTML = past.map(evt => {
          const eventDate = new Date(evt.date);
          const formattedDate = eventDate.toLocaleDateString('fr-FR', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          });
          
          // Calculer les jours √©coul√©s
          const daysAgo = Math.floor((today - eventDate) / (1000 * 60 * 60 * 24));
          const daysText = daysAgo === 0 ? 'aujourd\'hui' : daysAgo === 1 ? 'hier' : `il y a ${daysAgo} jours`;
          
          return `
            <div style="padding: 1rem; margin-bottom: 0.5rem; background: rgba(100, 116, 139, 0.1); border-radius: 0.5rem; border-left: 3px solid #64748b; opacity: 0.85;">
              <h4 style="margin: 0 0 0.5rem 0; color: #94a3b8; font-size: 1rem;">${evt.name}</h4>
              <p style="margin: 0; color: #64748b; font-size: 0.9rem;">üìÖ ${formattedDate}</p>
              <p style="margin: 0.25rem 0 0 0; color: #94a3b8; font-size: 0.85rem;">‚è≥ ${daysText}</p>
              ${evt.description ? `<p style="margin: 0.5rem 0 0 0; color: #cbd5e1; font-size: 0.85rem;">${evt.description.substring(0, 120)}${evt.description.length > 120 ? '...' : ''}</p>` : ''}
            </div>
          `;
        }).join('');
        
      } catch (error) {
        console.error('Erreur lors du chargement de l\'historique:', error);
        pastEventsDiv.innerHTML = '<p style="color: #ef4444; text-align: center;">Erreur lors du chargement de l\'historique</p>';
      }
    }
    
    // Toggle l'affichage de l'historique
    let historyVisible = false;
    function toggleEventHistory() {
      const pastEventsDiv = document.getElementById('pastEvents');
      const toggleBtn = document.getElementById('toggleHistoryBtn');
      
      if (!pastEventsDiv || !toggleBtn) return;
      
      historyVisible = !historyVisible;
      pastEventsDiv.style.display = historyVisible ? 'block' : 'none';
      toggleBtn.textContent = historyVisible ? 'Masquer' : 'Afficher';
      
      if (historyVisible && pastEventsDiv.innerHTML.includes('Chargement')) {
        loadPastEvents();
      }
    }
    
    // Actualiser les √©v√©nements en cours
    async function refreshCurrentEvents() {
      const currentEventsDiv = document.getElementById('currentEvents');
      if (currentEventsDiv) {
        currentEventsDiv.innerHTML = '<p style="color: #94a3b8; text-align: center;">Actualisation...</p>';
        await loadCurrentEvents();
      }
    }
    
    // Charger tous les √©v√©nements apr√®s le chargement de la page
    document.addEventListener('DOMContentLoaded', () => {
      // Attendre que data.js soit charg√©
      setTimeout(async () => {
        await loadCurrentEvents();
        await loadUpcomingEvents();
        await loadAttendanceChart();
        // Charger l'historique seulement si l'utilisateur l'ouvre
      }, 1000);
      
      // Actualiser automatiquement les √©v√©nements en cours toutes les 5 minutes
      setInterval(loadCurrentEvents, 5 * 60 * 1000);
      // Actualiser le graphique toutes les 2 minutes
      setInterval(loadAttendanceChart, 2 * 60 * 1000);
    });
    
    // Charger et afficher le graphique d'√©volution du taux de pr√©sence
    async function loadAttendanceChart() {
      const chartContainer = document.getElementById('attendanceChartContainer');
      const chartCanvas = document.getElementById('attendanceChart');
      const chartLoading = document.getElementById('chartLoading');
      const chartNoData = document.getElementById('chartNoData');
      const averageRateEl = document.getElementById('averageRate');
      const totalEventsCountEl = document.getElementById('totalEventsCount');
      
      if (!chartCanvas || !chartContainer) return;
      
      try {
        // Obtenir l'utilisateur actuel (identifiant de connexion)
        const currentUsername = localStorage.getItem('appUser');
        if (!currentUsername) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          return;
        }
        
        // Obtenir le membre correspondant √† l'utilisateur
        const members = await window.supabaseDB.getMembers();
        const currentUser = await window.supabaseDB.getUserByUsername(currentUsername);
        if (!currentUser) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          return;
        }
        
        // Trouver le membre correspondant (par nom ou email)
        const member = members.find(m => 
          m.name === currentUser.name || 
          m.email === currentUser.email ||
          m.name.toLowerCase().includes(currentUser.name.toLowerCase())
        );
        
        if (!member) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          return;
        }
        
        // Obtenir tous les √©v√©nements et pr√©sences
        const events = await window.supabaseDB.getEvents();
        const attendancesRaw = await window.supabaseDB.getAttendances();
        
        // Normaliser les pr√©sences Supabase (member_id, event_id, status) vers un format commun
        const mapStatusToCode = (status) => {
          const statusMap = {
            'present': 'P',
            'absent': 'A',
            'excused': 'AJ',
            'late': 'L'
          };
          return statusMap[status] || status;
        };
        
        const attendances = attendancesRaw.map(a => ({
          memberId: a.member_id,
          eventId: a.event_id,
          status: mapStatusToCode(a.status),
          createdAt: a.created_at
        }));
        
        // Filtrer les pr√©sences de l'utilisateur
        const userAttendances = attendances.filter(a => {
          const attMemberId = typeof a.memberId === 'string' ? parseInt(a.memberId) : a.memberId;
          const memberId = typeof member.id === 'string' ? parseInt(member.id) : member.id;
          return attMemberId == memberId;
        });
        
        if (userAttendances.length === 0) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          totalEventsCountEl.textContent = '0';
          return;
        }
        
        // Trier les √©v√©nements par date
        const sortedEvents = [...events].sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Calculer le taux de pr√©sence pour chaque √©v√©nement
        const chartData = [];
        let totalPresent = 0;
        let totalEvents = 0;
        
        sortedEvents.forEach(event => {
          const eventId = typeof event.id === 'string' ? parseInt(event.id) : event.id;
          const attendance = userAttendances.find(a => {
            const attEventId = typeof a.eventId === 'string' ? parseInt(a.eventId) : a.eventId;
            return attEventId == eventId;
          });
          
          if (attendance) {
            totalEvents++;
            if (attendance.status === 'P') {
              totalPresent++;
            }
            const rate = totalEvents > 0 ? (totalPresent / totalEvents) * 100 : 0;
            chartData.push({
              date: new Date(event.date),
              rate: rate,
              eventName: event.name,
              status: attendance.status
            });
          }
        });
        
        if (chartData.length === 0) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          totalEventsCountEl.textContent = '0';
          return;
        }
        
        // Afficher les statistiques
        const averageRate = chartData.length > 0 
          ? (chartData[chartData.length - 1].rate).toFixed(1)
          : '0.0';
        averageRateEl.textContent = averageRate + '%';
        totalEventsCountEl.textContent = chartData.length;
        
        // Dessiner le graphique
        const ctx = chartCanvas.getContext('2d');
        const width = chartCanvas.offsetWidth;
        const height = 250;
        chartCanvas.width = width;
        chartCanvas.height = height;
        
        // Effacer le canvas
        ctx.clearRect(0, 0, width, height);
        
        if (chartData.length === 0) {
          chartLoading.style.display = 'none';
          chartNoData.style.display = 'block';
          return;
        }
        
        // Configuration du graphique
        const padding = { top: 20, right: 20, bottom: 40, left: 50 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        
        // Dessiner les axes
        ctx.strokeStyle = '#64748b';
        ctx.lineWidth = 1;
        
        // Axe Y (vertical)
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, padding.top + chartHeight);
        ctx.stroke();
        
        // Axe X (horizontal)
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top + chartHeight);
        ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight);
        ctx.stroke();
        
        // Dessiner les lignes de grille
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= 5; i++) {
          const y = padding.top + (chartHeight / 5) * i;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + chartWidth, y);
          ctx.stroke();
          
          // Labels Y (0%, 20%, 40%, 60%, 80%, 100%)
          ctx.fillStyle = '#94a3b8';
          ctx.font = '10px sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText((100 - i * 20) + '%', padding.left - 10, y + 4);
        }
        
        // Dessiner la ligne d'√©volution
        if (chartData.length > 0) {
          ctx.strokeStyle = '#00d4ff';
          ctx.lineWidth = 3;
          ctx.beginPath();
          
          chartData.forEach((point, index) => {
            const x = padding.left + (chartWidth / (chartData.length - 1 || 1)) * index;
            const y = padding.top + chartHeight - (point.rate / 100) * chartHeight;
            
            if (index === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          });
          
          ctx.stroke();
          
          // Dessiner les points
          chartData.forEach((point, index) => {
            const x = padding.left + (chartWidth / (chartData.length - 1 || 1)) * index;
            const y = padding.top + chartHeight - (point.rate / 100) * chartHeight;
            
            // Couleur selon le statut
            const color = point.status === 'P' ? '#10b981' : 
                         point.status === 'A' ? '#ef4444' : 
                         point.status === 'AJ' ? '#f97316' : '#64748b';
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // Point blanc au centre
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        
        // Labels X (dates)
        ctx.fillStyle = '#94a3b8';
        ctx.font = '9px sans-serif';
        ctx.textAlign = 'center';
        
        const labelStep = Math.max(1, Math.floor(chartData.length / 5));
        chartData.forEach((point, index) => {
          if (index % labelStep === 0 || index === chartData.length - 1) {
            const x = padding.left + (chartWidth / (chartData.length - 1 || 1)) * index;
            const dateStr = point.date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' });
            ctx.fillText(dateStr, x, padding.top + chartHeight + 20);
          }
        });
        
        chartLoading.style.display = 'none';
        
      } catch (error) {
        console.error('Erreur lors du chargement du graphique:', error);
        chartLoading.style.display = 'none';
        chartNoData.style.display = 'block';
      }
    }
    
    // Exposer les fonctions globalement
    window.refreshCurrentEvents = refreshCurrentEvents;
    window.toggleEventHistory = toggleEventHistory;
    
  </script>
</body>
</html>

